---
title: mysql锁的那些事
date: 2019-06-12 12:08:17
tags:
---

***

<span style="color:red;font-size:25px">针对于innodb，事务级别为RR</span>

---

innodb实现的是著名的多版本并发控制协议（MVCC）,他的最大好处是读不加锁，这对目前的高并发场景是十分重要的。

分析锁时区分当前读和快照读，快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。

###  共享锁，排他锁（S,X）

- **快照读：**简单的select操作，属于快照读，不加锁。

  - select * from table where ?;

  

- **当前读：**特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。

  - select * from table where ? lock in share mode;
  - select * from table where ? for update;
  - insert /update/delete

  所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。

### 间隙锁（GAP）

innodb使用间隙所来解决幻读的问题，不仅在行上加锁，还会在周围加上间隙所来保证可重复读。

### 意向锁（IS,IX）

对于需要获得行锁的事务需要先获得表上面的意向锁。

### 死锁

死锁的发生与否，并不在于事务中有多少条SQL语句，**死锁的关键在于**：两个(或以上)的Session**加锁的顺序**不一致。而使用本文上面提到的，分析MySQL每条SQL语句的加锁规则，分析出每条语句的加锁顺序，然后检查多个并发SQL间是否存在以相反的顺序加锁的情况，就可以分析出各种潜在的死锁情况，也可以分析出线上死锁发生的原因。

举一个简单的例子：

``` bash
#session one
mysql> select * from d where a=1 lock in share mode;
#session two
update d set c=1  where a=1 ;
#session one 
update d set c=1  where a=1 ;
```

发生死锁，原因在于会话一获取了a=1行上的S锁，会话二获取X锁时需要先获取S锁，但是S锁未被释放，因此需要在锁队列中等待，而会话一再次尝试获取X锁，需要等待会话二释放X锁，因此死锁。



### 事物回滚

mysql的死锁检测到之后，会选择一个事务进行回滚。而选择的依据：看哪个事务的权重最小，事务权重的计算方法：事务加的锁最少；事务写的日志最少；事务开启的时间最晚。

